<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gradient Descent Visualization</title>
  <style>
    :root{ 
      --bg: transparent;
      --mesh: #f0f0f0;
      --edges: #bbbbbb;
      --dot: #bd3c49;
      --trail: #bd3c49;
      --target: #000000;
      --approx: #df9da6;
      --start-square: #bd3c49;
      --end-square: #7a7a7a00;
    }
    html, body { 
      height: 100%; 
      margin: 0; 
      background: transparent;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #container {
      position: fixed;
      inset: 0;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      cursor: pointer;
    }
    #viz-wrapper {
      display: flex;
      flex-direction: column;
      gap: 5px;
      align-items: center;
      width: 100%;
      max-width: 100%;
    }
    #loss-surface {
      width: 100%;
      height: 55vh;
    }
    #function-plot {
      width: 100%;
      height: 45vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="viz-wrapper">
      <div id="loss-surface"></div>
      <div id="function-plot"></div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  // Configuration
  const CONFIG = {
    // Display options
    showLossSurface: true,  // Show 3D loss surface
    showFunction: false,     // Show 2D function plot
    
    // 3D Surface - Low poly
    size: 3,
    segments: 90, // Low poly
    bowlX: 0.8,
    bowlZ: 1.2,
    coupling: 0.4,
    rippleAmp: 0.2,
    rippleFreqX: 2.5,
    rippleFreqZ: 3.2,
    secondaryRippleAmp: 0.1,
    secondaryRippleFreq: 5.5,
    noiseScale: 0.2,
    
    // Animation
    cycleSeconds: 4,
    stepsPerCycle: 60,
    eta: 0.09,
    momentum: 0.5,
    
    // Aesthetics
    meshOpacity: 0.15,
    edgeWidth: 1,    // Width of wireframe edges (limited by WebGL)
    sketchyAmount: 0.002,  // Amount of hand-drawn wobble (0 = perfect grid)
    trailLength: 50,
    dotRadius: 0.02,
    
    // 2D Function
    functionSamples: 250,
    targetOpacity: 1.0,
    approxOpacity: 0.2,
    maxOverlays: 30
  };

  // ===== DYNAMIC LAYOUT =====
  // Update element visibility and sizing based on config
  const mount3D = document.getElementById('loss-surface');
  const mount2D = document.getElementById('function-plot');
  
  if (!CONFIG.showLossSurface) {
    mount3D.style.display = 'none';
  }
  if (!CONFIG.showFunction) {
    mount2D.style.display = 'none';
  }
  
  // Adjust heights based on what's shown
  let height3DRatio, height2DRatio;
  if (CONFIG.showLossSurface && CONFIG.showFunction) {
    height3DRatio = 0.55;
    height2DRatio = 0.45;
  } else if (CONFIG.showLossSurface && !CONFIG.showFunction) {
    height3DRatio = 1.0;
    height2DRatio = 0;
  } else if (!CONFIG.showLossSurface && CONFIG.showFunction) {
    height3DRatio = 0;
    height2DRatio = 1.0;
  } else {
    height3DRatio = 0.5;
    height2DRatio = 0.5;
  }
  
  mount3D.style.height = `${height3DRatio * 100}vh`;
  mount2D.style.height = `${height2DRatio * 100}vh`;
  
  // ===== 3D LOSS SURFACE =====
  let scene, renderer, camera, mesh, wireframe, dot, trail, trailGeom, trailPositions;
  let startSquareIndex = -1;
  let endSquareIndex = -1;
  let squareMeshes = [];
  
  if (CONFIG.showLossSurface) {
    scene = new THREE.Scene();
    
    // Get actual dimensions
    const width3D = mount3D.clientWidth || window.innerWidth;
    const height3D = window.innerHeight * height3DRatio;
  
    renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true 
    });
    renderer.setClearColor(0x000000, 0);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(width3D, height3D);
    mount3D.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(35, width3D / height3D, 0.1, 100);
    camera.position.set(6, 4, 6);
    camera.lookAt(0, 0, 0);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.4);
    dir.position.set(5, 8, 3);
    scene.add(dir);

    // Low poly surface mesh
    const segments = Math.floor(CONFIG.segments);
    const geom = new THREE.PlaneGeometry(CONFIG.size, CONFIG.size, segments, segments);
    geom.rotateX(-Math.PI/2);
    
    // Add sketchy hand-drawn distortion to vertices
    const pos = geom.attributes.position;
    const sketchyOffsets = new Float32Array(pos.count * 3);
    for (let i = 0; i < pos.count; i++) {
      // Create persistent random offsets for each vertex
      sketchyOffsets[i * 3] = (Math.random() - 0.5) * CONFIG.sketchyAmount * CONFIG.size;
      sketchyOffsets[i * 3 + 1] = 0; // Don't distort Y (height)
      sketchyOffsets[i * 3 + 2] = (Math.random() - 0.5) * CONFIG.sketchyAmount * CONFIG.size;
    }
    
    // Store original positions and offsets for later use
    geom.userData.sketchyOffsets = sketchyOffsets;
    geom.userData.originalPositions = pos.array.slice();

    // Flat shaded material for low poly look
    const mat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh').trim()),
      transparent: true,
      opacity: CONFIG.meshOpacity,
      side: THREE.DoubleSide
    });
    mesh = new THREE.Mesh(geom, mat);
    scene.add(mesh);
    
    // Create individual square meshes for shading
    const squareSize = CONFIG.size / segments;
    const squareGeom = new THREE.PlaneGeometry(squareSize * 0.95, squareSize * 0.95); // Slightly smaller to avoid z-fighting
    squareGeom.rotateX(-Math.PI/2);
    
    for (let j = 0; j < segments; j++) {
      for (let i = 0; i < segments; i++) {
        const squareMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--mesh').trim()),
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide
        });
        const squareMesh = new THREE.Mesh(squareGeom.clone(), squareMat);
        // Position will be set during animation
        squareMesh.visible = false;
        scene.add(squareMesh);
        squareMeshes.push(squareMesh);
      }
    }

    // Custom wireframe with square grid (no diagonals)
    const wireGeom = new THREE.BufferGeometry();
    const wireIndices = [];
    
    // Create horizontal and vertical lines only (no diagonals)
    const gridSize = segments + 1;
    
    // Horizontal lines
    for (let j = 0; j < gridSize; j++) {
      for (let i = 0; i < segments; i++) {
        const idx = j * gridSize + i;
        wireIndices.push(idx, idx + 1);
      }
    }
    
    // Vertical lines
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < segments; j++) {
        const idx = j * gridSize + i;
        wireIndices.push(idx, idx + gridSize);
      }
    }
    
    // Share vertices with the mesh but create custom edges
    wireGeom.setAttribute('position', geom.getAttribute('position'));
    wireGeom.setIndex(wireIndices);
    
    const wireMat = new THREE.LineBasicMaterial({
      color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--edges').trim()),
      linewidth: CONFIG.edgeWidth
    });
    wireframe = new THREE.LineSegments(wireGeom, wireMat);
    scene.add(wireframe);

    // Dot
    const dotGeom = new THREE.SphereGeometry(CONFIG.dotRadius, 8, 8);
    const dotMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--dot').trim())
    });
    dot = new THREE.Mesh(dotGeom, dotMat);
    scene.add(dot);

    // Trail
    trailGeom = new THREE.BufferGeometry();
    const trailMat = new THREE.LineBasicMaterial({
      color: new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--trail').trim()),
      transparent: true,
      opacity: 0.3
    });
    trailPositions = new Float32Array((CONFIG.trailLength + 1) * 3);
    trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trail = new THREE.Line(trailGeom, trailMat);
    scene.add(trail);
  }

  // Surface function (shared between both modes)
  const L = CONFIG.size / 2;
  const coefs = {
    a: CONFIG.bowlX,
    b: CONFIG.bowlZ,
    c: CONFIG.coupling,
    kx: CONFIG.rippleFreqX,
    kz: CONFIG.rippleFreqZ,
    phase: 0
  };

  function f(x, z) {
    const u = x / L;
    const v = z / L;
    
    // Primary bowl shape
    const bowl = coefs.a * u * u + coefs.b * v * v + coefs.c * u * v;
    
    // Primary ripples
    const ripple1 = CONFIG.rippleAmp * Math.sin(coefs.kx * u + coefs.kz * v + coefs.phase);
    
    // Secondary ripples for more detail
    const ripple2 = CONFIG.secondaryRippleAmp * Math.cos(CONFIG.secondaryRippleFreq * u * v + coefs.phase * 1.5);
    
    // Additional waves for complexity
    const wave1 = CONFIG.noiseScale * Math.sin(3.7 * u + coefs.phase * 0.8) * Math.cos(2.3 * v);
    const wave2 = CONFIG.noiseScale * 0.7 * Math.sin(5.2 * v - coefs.phase * 1.2) * Math.sin(4.1 * u);
    
    // Localized bumps and valleys
    const bump1 = CONFIG.noiseScale * 0.5 * Math.exp(-2 * ((u - 0.5) * (u - 0.5) + (v - 0.3) * (v - 0.3)));
    const bump2 = -CONFIG.noiseScale * 0.4 * Math.exp(-3 * ((u + 0.4) * (u + 0.4) + (v - 0.6) * (v - 0.6)));
    
    return bowl + ripple1 + ripple2 + wave1 + wave2 + bump1 + bump2;
  }

  function grad(x, z) {
    const eps = 1e-3 * CONFIG.size;
    const fx1 = f(x + eps, z);
    const fx0 = f(x - eps, z);
    const fz1 = f(x, z + eps);
    const fz0 = f(x, z - eps);
    return { gx: (fx1 - fx0) / (2 * eps), gz: (fz1 - fz0) / (2 * eps) };
  }
  
  // Get which square index a position is in
  function getSquareIndex(x, z) {
    if (!CONFIG.showLossSurface) return -1;
    const segments = Math.floor(CONFIG.segments);
    const halfSize = CONFIG.size / 2;
    const squareSize = CONFIG.size / segments;
    
    // Convert world position to grid indices
    const i = Math.floor((x + halfSize) / squareSize);
    const j = Math.floor((z + halfSize) / squareSize);
    
    // Clamp to valid range
    if (i < 0 || i >= segments || j < 0 || j >= segments) return -1;
    
    return j * segments + i;
  }
  
  // Update square shading
  function updateSquareShading(squareIndex, color, opacity) {
    if (!CONFIG.showLossSurface || squareIndex < 0 || squareIndex >= squareMeshes.length) return;
    
    const segments = Math.floor(CONFIG.segments);
    const halfSize = CONFIG.size / 2;
    const squareSize = CONFIG.size / segments;
    
    const i = squareIndex % segments;
    const j = Math.floor(squareIndex / segments);
    
    const squareMesh = squareMeshes[squareIndex];
    
    // Position the square overlay at the correct location
    const centerX = -halfSize + (i + 0.5) * squareSize;
    const centerZ = -halfSize + (j + 0.5) * squareSize;
    const centerY = f(centerX, centerZ) + 0.01; // Higher above surface to ensure visibility
    
    squareMesh.position.set(centerX, centerY, centerZ);
    squareMesh.material.color = new THREE.Color(color);
    squareMesh.material.opacity = opacity;
    squareMesh.visible = opacity > 0;
  }
  
  // Clear all square shading
  function clearSquareShading() {
    squareMeshes.forEach(mesh => {
      mesh.visible = false;
      mesh.material.opacity = 0;
    });
  }

  // Update surface
  function updateSurface() {
    if (!CONFIG.showLossSurface) return;
    const pos = mesh.geometry.attributes.position;
    const sketchyOffsets = mesh.geometry.userData.sketchyOffsets;
    const originalPositions = mesh.geometry.userData.originalPositions;
    
    for (let i = 0; i < pos.count; i++) {
      // Get original position
      const origX = originalPositions[i * 3];
      const origZ = originalPositions[i * 3 + 2];
      
      // Apply sketchy offset
      const x = origX + sketchyOffsets[i * 3];
      const z = origZ + sketchyOffsets[i * 3 + 2];
      
      // Update position with sketchy offset
      pos.setX(i, x);
      pos.setZ(i, z);
      
      // Calculate height based on distorted position
      pos.setY(i, f(x, z));
    }
    pos.needsUpdate = true;
    mesh.geometry.computeVertexNormals();
    
    // Update custom wireframe vertices (shares position buffer with mesh)
    wireframe.geometry.attributes.position.needsUpdate = true;
  }

  // ===== 2D FUNCTION PLOT =====
  let canvas2D, ctx;
  
  if (CONFIG.showFunction) {
    canvas2D = document.createElement('canvas');
    const width2D = mount2D.clientWidth || window.innerWidth;
    const height2D = window.innerHeight * height2DRatio;
    canvas2D.width = width2D;
    canvas2D.height = height2D;
    canvas2D.style.width = '100%';
    canvas2D.style.height = '100%';
    mount2D.appendChild(canvas2D);
    ctx = canvas2D.getContext('2d');
  }

  // Generate target function (Gaussian process-like)
  let targetFunction = [];
  function generateTargetFunction() {
    targetFunction = [];
    const n = CONFIG.functionSamples;
    
    // Generate more varied function with higher peaks and lower valleys
    const kernelPoints = 12;
    const kernelValues = Array(kernelPoints).fill(0).map(() => (Math.random() * 4 - 2)); // Increased range
    
    for (let i = 0; i < n; i++) {
      const x = (i / (n - 1)) * 2 * Math.PI;
      let y = 0;
      
      // Sum of weighted Gaussians for smooth curve with more variation
      for (let k = 0; k < kernelPoints; k++) {
        const center = (k / (kernelPoints - 1)) * 2 * Math.PI;
        const weight = Math.exp(-Math.pow(x - center, 2) / 0.3); // Sharper peaks
        y += kernelValues[k] * weight;
      }
      
      // Add some additional sinusoidal variation for more complexity
      y += Math.sin(x * 2.5) * 0.3 + Math.cos(x * 1.7) * 0.2;
      
      targetFunction.push({ x, y: y * 0.5 }); // Increased amplitude
    }
  }

  // Convert function value to canvas coordinates
  function toCanvas(x, y) {
    const padding = 40;
    const width = canvas2D.width - 2 * padding;
    const height = canvas2D.height - 2 * padding;
    
    const canvasX = padding + (x / (2 * Math.PI)) * width;
    const canvasY = padding + height/2 - y * height/4; // Adjusted for larger range
    
    return { x: canvasX, y: canvasY };
  }

  // Draw function
  function drawFunction(points, color, opacity, lineWidth = 1.5, behindTarget = false) {
    if (points.length < 2) return;
    
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    if (behindTarget) {
      ctx.globalCompositeOperation = 'destination-over';
    }
    
    ctx.beginPath();
    
    const start = toCanvas(points[0].x, points[0].y);
    ctx.moveTo(start.x, start.y);
    
    for (let i = 1; i < points.length; i++) {
      const p = toCanvas(points[i].x, points[i].y);
      ctx.lineTo(p.x, p.y);
    }
    
    ctx.stroke();
    ctx.restore();
  }

  // LOESS-style local smoothing approximation
  function generateApproximation(span, noiseLevel) {
    const points = [];
    const n = CONFIG.functionSamples;
    
    // Calculate global approximation components
    const targetMean = targetFunction.reduce((sum, p) => sum + p.y, 0) / targetFunction.length;
    const trend = (Math.random() - 0.5) * 0.3;
    
    for (let i = 0; i < n; i++) {
      const x = (i / (n - 1)) * 2 * Math.PI;
      
      // Global smooth approximation
      let globalY = targetMean + trend * Math.sin(x * 0.5);
      globalY += Math.sin(x * 0.3) * noiseLevel * 1.2;
      globalY += Math.cos(x * 0.7) * noiseLevel * 0.8;
      globalY += Math.sin(x * 0.2) * noiseLevel * 0.6;
      
      // Local LOESS approximation
      let localY = 0;
      let weightedSum = 0;
      let weightSum = 0;
      
      const spanWidth = span * Math.PI;
      
      for (let j = 0; j < targetFunction.length; j++) {
        const targetPoint = targetFunction[j];
        const distance = Math.abs(targetPoint.x - x);
        const wrapDistance = Math.min(distance, 2 * Math.PI - distance);
        
        if (wrapDistance <= spanWidth) {
          const u = wrapDistance / spanWidth;
          const weight = u <= 1 ? Math.pow(1 - Math.pow(u, 3), 3) : 0;
          
          weightedSum += targetPoint.y * weight;
          weightSum += weight;
        }
      }
      
      localY = weightSum > 0 ? weightedSum / weightSum : globalY;
      
      // Smooth transition between global and local
      // When span > 2.5: mostly global
      // When span < 0.8: mostly local  
      // In between: gradual blend
      let blendFactor = 0;
      if (span > 2.5) {
        blendFactor = 0; // All global
      } else if (span < 0.8) {
        blendFactor = 1; // All local
      } else {
        // Smooth transition from 0 to 1
        blendFactor = (2.5 - span) / (2.5 - 0.8);
        blendFactor = Math.pow(blendFactor, 2); // Ease in curve
      }
      
      // Blend global and local approximations
      let y = globalY * (1 - blendFactor) + localY * blendFactor;
      
      // Add noise that decreases with better fits
      const noiseAmount = noiseLevel * (1 - blendFactor * 0.7);
      const randomNoise = (Math.random() - 0.5) * 2 * noiseAmount * 0.4;
      y += randomNoise;
      
      points.push({ x, y });
    }
    
    return points;
  }

  // ===== ANIMATION LOOP =====
  let startTime = Date.now();
  let currentStep = 0;
  let pathHistory = [];
  let approximations = [];
  let skipToNext = false;
  
  // Initialize position
  let pos = { x: L * 0.8, z: L * 0.8 };
  let vel = { x: 0, z: 0 };
  
  // Camera view state
  let cameraView = 'top'; // 'side' or 'top'
  let cameraTransition = 1; // 0 to 1 during transition (1 = fully transitioned)
  let cameraTransitionSpeed = 0.05; // Speed of transition
  
  // LOESS parameters that improve during descent
  let loessParams = {
    span: 3.5,      // Start with very wide span (oversmoothed)
    noiseLevel: 0.4  // Start with moderate noise
  };

  generateTargetFunction();

  // Add click handler to toggle camera view
  document.getElementById('container').addEventListener('click', (e) => {
    e.preventDefault();
    if (CONFIG.showLossSurface) {
      // Toggle between side and top view
      cameraView = cameraView === 'side' ? 'top' : 'side';
      cameraTransition = 0; // Reset transition
    }
  });

  function animate() {
    requestAnimationFrame(animate);
    
    const now = Date.now();
    const elapsed = (now - startTime) / 1000;
    let cycleTime = elapsed % CONFIG.cycleSeconds;
    
    // Handle skip to next loop
    if (skipToNext) {
      startTime = now - (CONFIG.cycleSeconds * 1000); // Force cycle end
      cycleTime = CONFIG.cycleSeconds;
      skipToNext = false;
    }
    
    const stepProgress = (cycleTime / CONFIG.cycleSeconds) * CONFIG.stepsPerCycle;
    const step = Math.floor(stepProgress);
    
    // Reset at cycle start or when skipping
    if ((step === 0 && currentStep !== 0) || cycleTime >= CONFIG.cycleSeconds) {
      pos = { x: L * 0.7 * (Math.random() * 2 - 1), z: L * 0.7 * (Math.random() * 2 - 1) };
      vel = { x: 0, z: 0 };
      pathHistory = [];
      approximations = [];
      generateTargetFunction();
      
      // Clear previous shading and mark start square
      clearSquareShading();
      startSquareIndex = getSquareIndex(pos.x, pos.z);
      updateSquareShading(startSquareIndex, 
        getComputedStyle(document.documentElement).getPropertyValue('--start-square').trim(), 
        0.6);
      endSquareIndex = -1;
      
      // Reset LOESS parameters
      loessParams = {
        span: 3.0 + Math.random() * 1.0,    // Start very oversmoothed
        noiseLevel: 0.35 + Math.random() * 0.15  // Start with moderate noise
      };
    }
    
    // Update gradient descent
    if (step !== currentStep) {
      const g = grad(pos.x, pos.z);
      vel.x = CONFIG.momentum * vel.x + (1 - CONFIG.momentum) * g.gx;
      vel.z = CONFIG.momentum * vel.z + (1 - CONFIG.momentum) * g.gz;
      pos.x -= CONFIG.eta * vel.x;
      pos.z -= CONFIG.eta * vel.z;
      
      // Clamp position
      pos.x = Math.max(-L * 0.95, Math.min(L * 0.95, pos.x));
      pos.z = Math.max(-L * 0.95, Math.min(L * 0.95, pos.z));
      
      pathHistory.push({ ...pos });
      
      // Improve LOESS fit (decrease span = tighter fit, decrease noise)
      const progress = step / CONFIG.stepsPerCycle;
      
      // Progressive span reduction for tighter fit (slower with more iterations)
      const targetSpan = 0.15; // Very tight final fit
      const spanReduction = (loessParams.span - targetSpan) * 0.04;
      loessParams.span = Math.max(targetSpan, loessParams.span - spanReduction);
      
      // Progressive noise reduction (slower with more iterations)
      const targetNoise = 0.02; // Almost no noise at the end
      const noiseReduction = (loessParams.noiseLevel - targetNoise) * 0.07;
      loessParams.noiseLevel = Math.max(targetNoise, loessParams.noiseLevel - noiseReduction);
      
      // Add new approximation
      approximations.push(generateApproximation(loessParams.span, loessParams.noiseLevel));
      if (approximations.length > CONFIG.maxOverlays) {
        approximations.shift();
      }
      
      // End square marking removed - only showing start square
      
      currentStep = step;
    }
    
    // Update 3D surface if shown
    if (CONFIG.showLossSurface) {
      // coefs.phase = elapsed * 0.15;
      updateSurface();
      
      // Re-update shaded squares positions after surface update
      if (startSquareIndex >= 0) {
        updateSquareShading(startSquareIndex, 
          getComputedStyle(document.documentElement).getPropertyValue('--start-square').trim(), 
          0.6);
      }
      
      // Update dot position
      const y = f(pos.x, pos.z);
      dot.position.set(pos.x, y + 0.03, pos.z);
      
      // Update trail
      const trailCount = Math.min(pathHistory.length, CONFIG.trailLength);
      for (let i = 0; i < trailCount; i++) {
        const p = pathHistory[pathHistory.length - trailCount + i];
        const idx = i * 3;
        trailPositions[idx] = p.x;
        trailPositions[idx + 1] = f(p.x, p.z) + 0.002;
        trailPositions[idx + 2] = p.z;
      }
      trailGeom.attributes.position.needsUpdate = true;
      trailGeom.setDrawRange(0, trailCount);
      
      // Camera animation with smooth transition
      if (cameraTransition < 1) {
        cameraTransition = Math.min(1, cameraTransition + cameraTransitionSpeed);
      }
      
      const angle = elapsed * 0.08;
      
      // Define camera positions
      const sidePos = {
        x: Math.cos(angle) * 6,
        y: 4,
        z: Math.sin(angle) * 6
      };
      
      const topPos = {
        x: 0,
        y: 10,
        z: 0.01 // Slight offset to avoid gimbal lock
      };
      
      // Interpolate between positions based on current view
      let targetPos, currentPos;
      if (cameraView === 'top') {
        currentPos = sidePos;
        targetPos = topPos;
      } else {
        currentPos = topPos;
        targetPos = sidePos;
      }
      
      // Smooth easing function (ease-in-out)
      const t = cameraTransition;
      const easedT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      
      // Interpolate camera position
      camera.position.x = currentPos.x + (targetPos.x - currentPos.x) * easedT;
      camera.position.y = currentPos.y + (targetPos.y - currentPos.y) * easedT;
      camera.position.z = currentPos.z + (targetPos.z - currentPos.z) * easedT;
      
      camera.lookAt(0, 0, 0);
      
      // Render 3D
      renderer.render(scene, camera);
    }
    
    // Clear and render 2D if shown
    if (CONFIG.showFunction) {
      ctx.clearRect(0, 0, canvas2D.width, canvas2D.height);
      
      // Draw subtle axis
      ctx.strokeStyle = '#d0d0d0';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(60, canvas2D.height/2);
      ctx.lineTo(canvas2D.width - 60, canvas2D.height/2);
      ctx.stroke();
      
      // Draw approximations BEHIND target (older ones are fainter)
      approximations.forEach((approx, i) => {
        const age = i / approximations.length;
        const opacity = CONFIG.approxOpacity * (0.5 + 0.5 * age);
        drawFunction(approx, getComputedStyle(document.documentElement).getPropertyValue('--approx').trim(), opacity, 1.2, true);
      });
      
      // Draw target function on top
      drawFunction(targetFunction, getComputedStyle(document.documentElement).getPropertyValue('--target').trim(), CONFIG.targetOpacity, 2, false);
    }
  }

  // Handle resize
  window.addEventListener('resize', () => {
    if (CONFIG.showLossSurface) {
      const newWidth3D = mount3D.clientWidth || window.innerWidth;
      const newHeight3D = window.innerHeight * height3DRatio;
      
      camera.aspect = newWidth3D / newHeight3D;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth3D, newHeight3D);
    }
    
    if (CONFIG.showFunction) {
      const newWidth2D = mount2D.clientWidth || window.innerWidth;
      const newHeight2D = window.innerHeight * height2DRatio;
      
      canvas2D.width = newWidth2D;
      canvas2D.height = newHeight2D;
    }
  });
  
  animate();
  </script>
</body>
</html>